This repository will contain all of my assignments/projects for the 
course. Assignments will be polished in separate branches until ready 
for submission, at which time I will merge them into the main branch.

ksdb: Best not to put executables under version control. Assume that
users will recompile on their own machines. Unfortunately, the makefile 
in lab2 is broken, since you've moved all the code into subdirectories.

ksdb: In lab3, curves looks good. bitwise, fp, min, and denorm work
correctly. The sum and sumdata programs are nicely done. But I suggest
that you be sure to include a properly tailored makefile in each
subdirectory.

ksdb: In lab4, ratpow.py works correctly. series.py is showing the 
right values in the second column, which is confirmed in the plot
generated by "gnuplot -p view-series.py". The values in the third and 
fourth column, however, are a little off and don't seem to be converging
to the correct limit. Running "gnuplot -p view-series.py" confirms this.

Similarly, the second column of output from pi.py is correct, but the
third, fourth, and fifth columns are subtly off. When I run 
"gnuplot -p view-pi.gp", I can see that only the agm result achieves
a discrepancy on the order of the floating point epsilon.

In lab5, you need to change out all the ! ./series calls in view3.gp
for ! python3 series.py. The seriesroot.py program gives the right
output.

In lab6, it would be slightly more efficient to replace this

def R():
    global x0
    x = x0
    result = 0.0
    for i in range(52):
        x = blum(x)
        bit = x & 1
        result += bit * 2**(-i-1)
    x0 = x
    return result

with

def R():
    global x0
    x = x0
    result = 0.0
    val = 0.5
    for i in range(52):
        x = blum(x)
        bit = x & 1
        result += bit * val
        val *= 0.5
    x0 = x
    return result

so that you're not doing 52 exponentiations. But what you've written
work fine.

Your Box-Mueller RN() function looks good.

In well.py, don't add a drag term to the energy. Drag is an energy
loss mechanism, Drag(v)*x isn't useful work.

return 0.5*m*v*v + V(x) - (Drag(v)*x)
should be 
return 0.5*m*v*v + V(x)

You should play around with gamma and T values to see how this system
behaves. As gamma and T are ramped up, the narrow FT peak is thermally
broadened.

Final Project
=============

It looks like you've worked from a tutorial.py template and started
by distributing the class definitions and various functions across
several files.

In physics.py, there is a mathematical error. These exponentials

ax += (G*m2*x)/r**2
ay += (G*m2*y)/r**2

should be **3. Remember that

cos(theta)/r**2 = x/r**3
sin(theta)/r**2 = y/r**3

Your verlet implementation also has a problem. The way you've
set things up, x and prev_x are identical on line 45.

41    self.prev_x = self.x 
42    self.prev_y = self.y
43
44    ax, ay = accel(self, celestial_bodies)
45    self.x = (2 * self.x) - self.prev_x + (ax * dt**2)
46    self.y = (2 * self.y) - self.prev_y + (ay * dt**2)
47 
48    self.prev_x = self.x 
49    self.prev_y = self.y

Also, I think you're misconstruing how "self" works. This is how 
you refer to the object itself when you are inside a class definition.
It doesn't make sense in update_position in main.py or the verlet 
function in physics.py. In tutorial.py, by contrast, update_position
needs a self argument because it is defined as a member function
of the Planet class.

Currently, when I run main.py, I see the initial setup of the planets,
but they do not move at all.

# phys540
